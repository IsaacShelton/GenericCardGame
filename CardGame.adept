
#default CardGame_backslash_to_show_pending_actions false

import 'main.adept'
import 'drawutils.adept'
import 'listutils.adept'
import 'Optional.adept'
import 'GameAlert.adept'
import 'GameState.adept'
import 'AttackOrder.adept'
import 'CardAnimation.adept'
import 'CardParticle.adept'

HUGE_CARD_SCALE == 2.0f
CARD_WIDTH   == 64.0f
CARD_HEIGHT  == 96.0f
CARD_INFO_WIDTH  == 12.8f
CARD_INFO_HEIGHT == 96.0f
MANA_WIDTH   == 24.0f
MANA_HEIGHT  == 24.0f
HEART_WIDTH  == 24.0f
HEART_HEIGHT == 24.0f
CARD_PADDING == 16.0f
MANA_PADDING == 8.0f
HEART_PADDING == 8.0f
CARD_XADVANCE == CARD_WIDTH + CARD_PADDING
CARD_YADVANCE == CARD_HEIGHT + CARD_PADDING
MANA_XADVANCE == MANA_WIDTH + MANA_PADDING
MANA_YADVANCE == MANA_HEIGHT + MANA_PADDING
HEART_XADVANCE == HEART_WIDTH + HEART_PADDING
HEART_YADVANCE == HEART_HEIGHT + HEART_PADDING
CARD_GAME_VERTICAL_OFFSET == -48.0f
PLAYING_SPELL_ORDER_DURATION == 2.0f

CARD_PICTURE_Y_OFFSET ==  50.0f / 300.0f * CARD_HEIGHT
CARD_PICTURE_HEIGHT   == 100.0f / 300.0f * CARD_HEIGHT
CARD_ELEMENT_WIDTH    == 12.0f
CARD_ELEMENT_HEIGHT   == 12.0f
CHARACTER_WIDTH       == 32.0f
CHARACTER_HEIGHT      == 32.0f

struct CardGame (
    state GameState,
    alert <GameAlert> Optional,
    dragging_card CardInstanceID,
    dragging_card_scale float,
    is_end_turn_button_hovered bool,
    is_draw_card_button_hovered bool,
    show_end_turn_button bool,
    show_draw_card_button bool,
    experimental_value float,
    attack_orders <AttackOrder> List,
    with_aggressor CardNetworkID,
    card_animations <*CardAnimation> List,
    scheduled_animations <ScheduledCardAnimation> List,
    playing_attack_order <AttackOrder> Optional,
    playing_spell_order <SpellOrder> Optional,
    playing_spell_order_start double,
    animated_attack_line_x, animated_attack_line_y float, // 0.0f == starting card position
    card_statuses <CardStatus> List,
    particles <*CardParticle> List,
    playing_wizards_aid_animation bool,
    wizards_aid_animation_beginning double,
    disco_opacity float
) {
    func setup {
        // UNUSED: Use enter(*CardGame) instead!
    }
    
    func __defer__ {
        // NOTE: Due to a compiler issue, we have to force a __defer__ method to
        // be automatically generated here
        
        this.clearAllAnimations()
        this.clearParticles()
    }
    
    func enter {
        // Reset structure to zero initialized state
        this.__defer__()
        memset(this, 0, sizeof CardGame)
        
        // Setup non-zero values
        this.show_end_turn_button = true
        this.show_draw_card_button = true
        this.playing_wizards_aid_animation = false
        
        this.displayAlert("Spawn Phase!")
        this.experimental_value = 1.0f
        
        this.state.init(gamedata.player_names)
        gamedata.interpreter.clearRoomMovements()
        
        this.disco_opacity = 0.0f
    }
    
    
    func exit {
        this.alert.rid()
        this.playing_attack_order.rid()
        this.playing_spell_order.rid()
        this.clearAllAnimations()
        this.clearParticles()
    }
    
    func step {
        // Find ourselves
        me *Player = this.state.getThisPlayer()
        
        // If someone leaves, consider it a victory
        if gamedata.interpreter.updatedRoomMovements(def movements <RoomMovement> List) {
            each RoomMovement in movements, unless it.isEnter {
                gamedata.leaveRoom()
                gamedata.setScene('victory')
                return
            }
        }
        
        // Get rid of dead alerts
        if this.alert.has {
            this.alert.getPointer().update()
            if this.alert.getPointer().shouldDie(), this.alert.rid()
        }
        
        // Auto advance phase after draw phase
        if this.state.phase.kind == PhaseKind::DRAW && !this.alert.has {
            this.endTurn()
        }
        
        // Process actions received from server
        gamedata.interpreter.updatedActions(func &handleActionsCallback(*CardGame, *Action) as ptr as func(ptr, *Action) successful, this)
        
        ready_to_advance_phase bool = !this.playing_spell_order.has && this.state.spell_orders.length == 0
        if this.state.willAdvancePhase() && this.state.spell_orders.length != 0 {
            // Play spell card animations
            unless this.playing_spell_order.has {
                spell_order SpellOrder = this.state.spell_orders.get(0)
                this.state.spell_orders.remove(0)
                
                victim *CardInstance = this.state.getCardOnBoardByNetworkId(spell_order.victim)
                this.state.doSpell(spell_order.player_id, spell_order.blueprint, victim, &this.particles, spell_order.randomness)
                this.card_statuses = this.state.getCardStatuses()
                
                player *Player = this.state.getPlayer(spell_order.player_id)
                if player && gamedata.gamekind != GameKind::VERSUS_AI && player != this.state.getThisPlayer(), player.hand.reduce(1)
                
                this.playing_spell_order.set(spell_order)
                this.playing_spell_order_start = glfwGetTime()
            }
        }
        
        // Advance the game phase if ready
        if ready_to_advance_phase && this.state.shouldAdvancePhase() {
            this.displayAlert(this.state.phase.toString() + "!")
            
            // Remove any playing attack order
            this.playing_attack_order.rid()
            
            switch this.state.phase.kind {
            case PhaseKind::DRAW
                this.state.doDrawPhase()
                this.show_end_turn_button = false
            case PhaseKind::SPAWN
                this.show_end_turn_button = true
                this.card_statuses = this.state.getCardStatuses()
            case PhaseKind::ATTACK
                this.attack_orders.clear()
                this.state.attack_orders.clear()
                this.card_statuses = this.state.getCardStatuses()
                this.show_end_turn_button = true
            case PhaseKind::BATTLE
                this.show_end_turn_button = false
            }
        }
        
        this.show_draw_card_button = (me && me.mana >= me.getDrawCost() && this.state.phase.kind == PhaseKind::SPAWN && this.show_end_turn_button)
        
        // Set whether buttons are hovered
        captMouseViewPosition(undef mouseX float, undef mouseY float)
        this.calculateWhetherEndTurnButtonIsHovered(mouseX, mouseY)
        this.calculateWhetherDrawCardButtonIsHovered(mouseX, mouseY)
        
        // Advance card animations
        this.card_animations.advanceAnimations()
        this.playScheduledAnimations()
        
        // Advance card particles
        this.particles.advanceParticles()
        
        // Do attacking in battle phase
        if this.state.phase.kind == PhaseKind::BATTLE && this.state.attack_orders.length != 0 && this.card_animations.length == 0 && this.scheduled_animations.length == 0 {
            // Update card statuses
            this.card_statuses = this.state.getCardStatuses()
            
            // Do damage from previously played attack
            order AttackOrder = this.state.attack_orders.get(0)
            this.state.attack_orders.remove(0)
            
            aggressor *CardInstance = this.state.getCardOnBoardByNetworkId(order.aggressor)
            victim *CardInstance = this.state.getCardOnBoardByNetworkId(order.victim)
            is_friendly bool = this.state.findOwner(order.aggressor) == this.state.findOwner(order.victim)
            
            if aggressor && victim {
                did_attack_work successful = this.state.doAttack(aggressor, &victim, &this.particles, order.randomness, order.is_counter)
                this.playAttackAnimation(aggressor, victim, did_attack_work, is_friendly)
                
                this.animated_attack_line_x = 0.0f // 0.0f == starting card x
                this.animated_attack_line_y = 0.0f // 0.0f == starting card y
                this.playing_attack_order.set(order)
            }
        }
        
        // Auto advance phase after battle phase
        if this.state.phase.kind == PhaseKind::BATTLE && !this.alert.has && this.state.attack_orders.length == 0 && this.state.spell_orders.length == 0 &&
                this.card_animations.length == 0 && this.scheduled_animations.length == 0 && !me.sent_done {
            
            // Update card statuses
            this.card_statuses = this.state.getCardStatuses()
            
            this.state.applyPassiveEffects(&this.particles)
            this.state.expireOldTraps()
            this.state.removeDeadCards(true)
            
            // Leave the game if lost
            if me.hearts <= 0 {
                gamedata.leaveRoom()
                gamedata.setScene('defeat')
                return
            }
            
            this.endTurn()
        }
        
        // Update disco opacity
        if this.state.global_dancing != 0 {
            this.disco_opacity = (this.disco_opacity * 19.0f + 0.25f) / 20.0f
        } else if this.disco_opacity > 0.0f {
            this.disco_opacity = this.disco_opacity < 0.0001f ? 0.0f : this.disco_opacity * 19.0f / 20.0f
        }
        
        // Perform AI
        if gamedata.gamekind == GameKind::VERSUS_AI,
            this.processAI()
    }
    
    func click(x, y float, button int){
        unless button == 1, return
        
        // Find ourselves
        me *Player = this.state.getThisPlayer()
        
        // End our turn if the 'end turn' button was clicked
        if this.show_end_turn_button && this.calculateWhetherEndTurnButtonIsHovered(x, y) {
            this.endTurn()
            sfx.play(sfx.button)
            return
        }
        
        // Draw a card when the 'draw card' button was clicked
        if this.show_draw_card_button && this.show_end_turn_button && this.calculateWhetherDrawCardButtonIsHovered(x, y) {
            me *Player = this.state.getThisPlayer()
            
            if me && !me.done && !me.sent_done && me.mana >= me.getDrawCost() {
                me.drawCardsFromDeck(1, true, this.state.global_mana)
                me.mana -= me.getDrawCost()
                gamedata.manager.writeOutgoing(gamedata.player_name + "@draw\n")
                sfx.play(sfx.button)
            }
            return
        }
        
        // When in spawn and attack phase, allow the player to drag and spawn cards
        if this.state.phase.kind == PhaseKind::SPAWN || this.state.phase.kind == PhaseKind::ATTACK {
            if me && me.hand.length > 0 && !me.sent_done {
                this.getMyHandCardPositions(def card_positions <CardPosition> List)
                each CardPosition in card_positions {
                    if it.intersecting(x, y) && allowed(me.hand.getPointer(idx).traits.usage, this.state.phase.kind) {
                        this.dragging_card = me.hand.getPointer(idx).instance_id
                        this.dragging_card_scale = it.scale
                        return
                    }
                }
            }
        }
        
        // When in attack phase, allow the player to drag attack vectors
        if this.state.phase.kind == PhaseKind::ATTACK {
            this.with_aggressor = 0
            if me && me.board.length > 0 && !me.sent_done {
                this.getMyBoardCardPositions(def card_positions <CardPosition> List)
                each CardPosition in card_positions {
                    card *CardInstance = me.board.getPointer(idx)
                    if !card.isDead() && !card.isDancing() && !card.traits.tripped && it.intersecting(x, y) {
                        this.with_aggressor = me.board.getPointer(idx).network_id
                        break
                    }
                }
            }
        }
    }
    
    func release(x, y float, button int){
        unless button == 1, return
        
        me *Player = this.state.getThisPlayer()
        
        // When in spawn phase or attack phase, allow the player to spawn in cards by dropping dragged cards
        if (this.state.phase.kind == PhaseKind::SPAWN || this.state.phase.kind == PhaseKind::ATTACK) &&
                this.dragging_card && y < captViewHeight() - CARD_HEIGHT {
            
            card *CardInstance = this.state.getMyCard(this.dragging_card)
            can_afford bool = me && !me.sent_done && card ? me.mana >= me.getDiscountedCardCost(card.cost) : false
            
            if can_afford && allowed(card.traits.usage, this.state.phase.kind) {
                switch card.kind {
                case CardKind::CREATURE
                    // If creature
                    
                    if me.supply < 4 || card.traits.separation {
                        rightof_network_id usize = 0
                        
                        if me.board.length != 0 {
                            this.getMyBoardCardPositions(def card_positions <CardPosition> List)
                            
                            each CardPosition in card_positions {
                                if it.x < x {
                                    rightof_network_id = me.board.getPointer(idx).network_id
                                    if rightof_network_id == 0, print("WARNING: CardGame.release() when placing card, was placed right of a card with network_id 0")
                                }
                            }
                        }
                        
                        gamedata.manager.writeOutgoing(gamedata.player_name + "@spawn ~ " + card.name + " rightof " + toString(rightof_network_id) + "\n")
                        me.mana -= me.getDiscountedCardCost(card.cost)
                        unless card.traits.separation, me.supply++
                        this.state.getRidOfMyCardInHand(this.dragging_card)
                    }
                case CardKind::SPELL
                    // If spell
                    target CardNetworkID = 0
                    
                    if card.traits.requires_target {
                        this.getBoardCardPositions(def network_ids <CardNetworkID> List, def card_positions <CardPosition> List)
                        each CardPosition in card_positions, if it.intersecting(x, y), target = network_ids.get(idx); break
                    }
                    
                    unless card.traits.requires_target && target == 0 {
                        // Play spell
                        play_command String = card.traits.urgent ? "@playnow " : "@play "
                        gamedata.manager.writeOutgoing(gamedata.player_name + play_command + card.name + " " + toString(target) + " `\n")
                        
                        // Give the mana immediately, and ignore the echo when it comes
                        // back over the network
                        if card.traits.gives_mana && me {
                            me.mana += card.traits.gives_mana
                            this.playWizardsAidAnimation()
                        }
                        
                        // Apply thrift immediately, and ignore the echo when it comes
                        // back over the network
                        if card.traits.thrift && me {
                            me.thrift += card.traits.thrift
                        }
                        
                        me.mana -= me.getDiscountedCardCost(card.cost)
                        this.state.getRidOfMyCardInHand(this.dragging_card)
                    }
                case CardKind::STAT
                    gamedata.manager.writeOutgoing(gamedata.player_name + "@spawn ~ " + card.name + " rightof 0\n")
                    me.mana -= me.getDiscountedCardCost(card.cost)
                    this.state.getRidOfMyCardInHand(this.dragging_card)
                case CardKind::TRAP
                    // If trap
                    target CardNetworkID = 0
                    
                    this.getBoardCardPositions(def network_ids <CardNetworkID> List, def card_positions <CardPosition> List)
                    each CardPosition in card_positions, if it.intersecting(x, y), target = network_ids.get(idx); break
                    
                    unless target == 0 {
                        // Play trap
                        gamedata.manager.writeOutgoing(gamedata.player_name + "@trap " + card.name + " " + toString(target) + "\n")
                        
                        me.mana -= me.getDiscountedCardCost(card.cost)
                        this.state.getRidOfMyCardInHand(this.dragging_card)
                    }
                }
                
                if me.mana < 0 {
                    print("ERROR: CardGame.release(): when placing card, me.mana fell negative")
                    me.mana = 0
                }
            }
        }
        
        if this.state.phase.kind == PhaseKind::ATTACK && this.with_aggressor != 0 && me && !me.sent_done {
            // Handle attack order
            victim_card *CardInstance = this.getOpponentCardUnderneath(x, y)
            
            aggressor_card *CardInstance = this.state.getCardOnBoardByNetworkId(this.with_aggressor)
            
            // If only allowed to heal, don't allow targetting enemy cards
            if aggressor_card.traits.only_heal, victim_card = null
            
            can_heal bool = aggressor_card.traits.can_heal || aggressor_card.traits.only_heal
            if victim_card == null && can_heal, victim_card = this.getMyCardUnderneath(x, y)
            
            // Don't allow targetting self
            if victim_card && this.with_aggressor == victim_card.network_id, victim_card = null
            
            if victim_card {
                this.attack_orders.add(attackOrder(this.with_aggressor, victim_card.network_id))
                this.attack_orders.enforceMaxAttacks(this.with_aggressor, aggressor_card.traits.attacks)
            } else {
                this.attack_orders.enforceMaxAttacks(this.with_aggressor, 0)
            }
        }
        
        // Stop dragging any cards we're dragging
        this.dragging_card = 0
        
        // Stop dragging any attack orders we're dragging
        this.with_aggressor = 0
    }
    
    func key(key, _scancode, _action, _mods int) {
        if key == GLFW_KEY_W, this.experimental_value += 0.01f
        if key == GLFW_KEY_S, this.experimental_value -= 0.01f
        
        #if CardGame_backslash_to_show_pending_actions
        if key == GLFW_KEY_BACKSLASH && _action == GLFW_PRESS {
            pthread_mutex_lock(&gamedata.interpreter.access_mutex)
            defer pthread_mutex_unlock(&gamedata.interpreter.access_mutex)
            
            each agent ActionAgent in gamedata.interpreter.agents {
                print("agent %:" % agent.name)
                each Action in agent.actions, print(" => %" % it.command_text)
            }
        }
        #end
    }
    
    func handleActionsCallback(action *Action) successful {
        // When unsuccessful, the agent's current and future actions will be postponed
        action.apply(&this.state, &this.particles, def should_reschedule bool, def should_update_card_statuses bool)
        
        if should_update_card_statuses {
            this.card_statuses = this.state.getCardStatuses()
        }
        
        if should_reschedule, return false
        return true
    }
    
    func draw {
        me *Player = this.state.getThisPlayer()
        opponent *Player = this.state.getOpponent()
        captMouseViewPosition(undef mouseX float, undef mouseY float)
        
        captDrawTexture(textures.background_brown, 0.0f, 0.0f, captViewWidth(), captViewHeight())
        
        notice_message String = gamedata.manager.getIsOnline() || gamedata.gamekind != GameKind::ONLINE ? "" : "You are Offline"
        
        unless notice_message.empty() {
            stride float = 14.0f / 7.0f * 6.0f
            textWidth float = stride * notice_message.length as float
            text Text = text(notice_message)
            text.draw(captViewWidth() / 2.0f - textWidth / 2.0f, captViewHeight() / 2.0f - 14.0f / 2.0f)
            text.destroy()
            return
        }
        
        if this.state.phase.kind == PhaseKind::ATTACK {
            captDrawOpacity(0.5f)
            if this.with_aggressor != 0 && this.getMyCardPositionFromNetworkID(this.with_aggressor, undef start CardPosition) {
                friendly bool = false
                end_x float = mouseX
                end_y float = mouseY
                
                using_card *CardInstance = this.state.getCardOnBoardByNetworkId(this.with_aggressor)
                victim *CardInstance = this.getOpponentCardUnderneath(mouseX, mouseY)
                
                // Don't allow attacking enemy if only allowed to heal
                if using_card.traits.only_heal, victim = null
                
                if victim == null {
                    can_heal bool = using_card.traits.can_heal || using_card.traits.only_heal
                    if can_heal, victim = this.getMyCardUnderneath(mouseX, mouseY)
                    
                    // Don't allow targetting self
                    if victim && this.with_aggressor == victim.network_id, victim = null
                    
                    if victim && this.getMyCardPositionFromNetworkID(victim.network_id, undef victim_position CardPosition) {
                        end_x = victim_position.x
                        end_y = victim_position.y
                        friendly = true
                    }
                }
                
                if victim {
                    victim_position CardPosition = undef
                    if this.getOpponentCardPositionFromNetworkID(victim.network_id, &victim_position) ||
                       this.getMyCardPositionFromNetworkID(victim.network_id, &victim_position) {
                        end_x = victim_position.x
                        end_y = victim_position.y
                    }
                } else {
                    friendly = using_card.traits.only_heal || (using_card.traits.can_heal && mouseY > captViewHeight() / 2.0f)
                }
                
                drawLine(start.x, start.y, end_x, end_y, 8.0f, EndCapStyle::ROUND, friendly ? &textures.heal_line : &textures.attack_line)
            }
            
            each AttackOrder in this.attack_orders {
                end CardPosition = undef
                if this.getMyCardPositionFromNetworkID(it.aggressor, undef start CardPosition) {
                    if this.getOpponentCardPositionFromNetworkID(it.victim, &end),
                        drawLine(start.x, start.y, end.x, end.y, 4.0f, EndCapStyle::ROUND, &textures.attack_line)
                    else if this.getMyCardPositionFromNetworkID(it.victim, &end),
                        drawLine(start.x, start.y, end.x, end.y, 4.0f, EndCapStyle::ROUND, &textures.heal_line)
                }
            }
            captDrawOpacity(1.0f)
        }
        
        if this.state.phase.kind == PhaseKind::BATTLE && this.playing_attack_order.has {
            start, end CardPosition
            
            has_start bool = this.getMyCardPositionFromNetworkID(this.playing_attack_order.getPointer().aggressor, &start) ||
                    this.getOpponentCardPositionFromNetworkID(this.playing_attack_order.getPointer().aggressor, &start)
            
            has_end bool = this.getMyCardPositionFromNetworkID(this.playing_attack_order.getPointer().victim, &end) ||
                    this.getOpponentCardPositionFromNetworkID(this.playing_attack_order.getPointer().victim, &end)
            
            friendly bool = this.state.findOwner(this.playing_attack_order.getPointer().victim) ==
                                this.state.findOwner(this.playing_attack_order.getPointer().aggressor)
            
            if has_start && this.animated_attack_line_x == 0.0f && this.animated_attack_line_y == 0.0f {
                this.animated_attack_line_x = start.x
                this.animated_attack_line_y = start.y
            }
            
            if has_end {
                this.animated_attack_line_x = (this.animated_attack_line_x * 9.0f + end.x) / 10.0f
                this.animated_attack_line_y = (this.animated_attack_line_y * 9.0f + end.y) / 10.0f
            }
            
            if has_start && has_end {
                captDrawOpacity(0.5f)
                drawLine(start.x, start.y, this.animated_attack_line_x, this.animated_attack_line_y, 4.0f, EndCapStyle::ROUND, friendly ? &textures.heal_line : &textures.attack_line)
                captDrawOpacity(1.0f)
            }
        }
        
        if this.show_end_turn_button {
            drawButton("end turn", this, func &getEndTurnButtonPosition(*CardGame, *float, *float), this.dragging_card != 0 ? false : this.is_end_turn_button_hovered)
        } else {
            drawButton("", this, func &getEndTurnButtonPosition(*CardGame, *float, *float), false)
        }
        
        if this.show_draw_card_button && this.show_end_turn_button {
            drawButton("draw card", this, func &getDrawCardButtonPosition(*CardGame, *float, *float), this.dragging_card != 0 ? false : this.is_draw_card_button_hovered)
        } else {
            drawButton("", this, func &getDrawCardButtonPosition(*CardGame, *float, *float), false)
        }
        
        this.drawOpponentsBoard()
        this.drawMyBoard()
        
        // Draw disco overlay
        if this.state.global_dancing != 0 {
            captDrawOpacity(this.disco_opacity)
            disco_transformation Matrix4f = undef
            disco_transformation.translateFromIdentity(captViewWidth() / 2.0f, captViewHeight() / 2.0f, 0.0f)
            disco_transformation.rotate(PI / 2.0f * glfwGetTime(), 0.0f, 0.0f, 1.0f)
            disco_transformation.translate(-500.0f, -500.0f, 0.0f)
            captDrawTextureUsingModelAndTransformation(models.disco, textures.disco, disco_transformation)
            captDrawOpacity(1.0f)
        }
        
        // Calculate current hearts/mana otherwise zero
        opponent_hearts int = opponent ? opponent.hearts : 0
        my_hearts int = me ? me.hearts : 0
        my_mana int = me && me.mana >= 0 ? me.mana : 0
        
        // Draw mana
        if this.alert.has, captDrawOpacity(this.alert.getPointer().getAmountAwayFromCenter())
        this.drawMana(captViewWidth() / 2.0f, captViewHeight() / 2.0f + CARD_GAME_VERTICAL_OFFSET, my_mana)
        captDrawOpacity(1.0f)
        
        // Draw friendly hearts
        if my_hearts > 0 {
            my_hearts_center_x float = 2.0f * HEART_PADDING + (HEART_WIDTH * my_hearts as float + HEART_PADDING * (my_hearts - 1) as float) / 2.0f
            this.drawHearts(my_hearts_center_x, 64.0f, my_hearts)
        }
        
        // Draw opponent hearts
        if opponent_hearts > 0 {
            opponent_hearts_center_x float = 2.0f * HEART_PADDING + (HEART_WIDTH * opponent_hearts as float + HEART_PADDING * (opponent_hearts - 1) as float) / 2.0f
            opponent_hearts_center_x = captViewWidth() - opponent_hearts_center_x
            this.drawHearts(opponent_hearts_center_x, 64.0f, opponent_hearts)
        }
        
        // Draw play names
        #if auto_name
            other_player_name String = "Andy"
            drawText("Isaac", 2.0f * HEART_PADDING, 16.0f)
            drawText(other_player_name, captViewWidth() - 2.0f * HEART_PADDING - TEXT_14_STRIDE * other_player_name.length as float, 16.0f)
        #else
            other_player_name String = opponent ? opponent.name : ""
            drawText(gamedata.player_name, 2.0f * HEART_PADDING, 16.0f)
            drawText(other_player_name, captViewWidth() - 2.0f * HEART_PADDING - TEXT_14_STRIDE * other_player_name.length as float, 16.0f)
        #end
        
        // Draw friendly super meter
        my_super_percent float = me ? clamp(me.super as float / 100.0f, 0.0f, 1.0f) : 0.0f
        captDrawTexture(textures.super_meter_background, 6.0f + 2.0f * HEART_PADDING, 35.0f, 256.0f, 14.0f)
        captDrawTexture(textures.super_meter_left_cap_full, 6.0f + 2.0f * HEART_PADDING - 12.0f, 35.0f, 12.0f, 14.0f)
        captDrawTexture(my_super_percent >= 1.0f ? textures.super_meter_right_cap_full : textures.super_meter_right_cap, 6.0f + 2.0f * HEART_PADDING + 256.0f, 35.0f, 12.0f, 14.0f)
        captDrawTexture(textures.super_meter, 6.0f + 2.0f * HEART_PADDING, 36.0f, 256.0f * my_super_percent, 12.0f)
        
        // Draw opponent super meter
        opponent_super_percent float = opponent ? clamp(opponent.super as float / 100.0f, 0.0f, 100.0f) : 0.0f
        captDrawTexture(textures.super_meter_background, captViewWidth() - 6.0f - 256.0f - 2.0f * HEART_PADDING, 35.0f, 256.0f, 14.0f)
        captDrawTexture(textures.super_meter, captViewWidth() - 6.0f - 256.0f * opponent_super_percent - 2.0f * HEART_PADDING, 36.0f, 256.0f * opponent_super_percent, 12.0f)
        
        captDrawTexture(textures.super_meter_right_cap_full, captViewWidth() - 6.0f - 2.0f * HEART_PADDING, 35.0f, 12.0f, 14.0f)
        
        captDrawTexture(opponent_super_percent >= 1.0f ? textures.super_meter_left_cap_full : textures.super_meter_left_cap,
            captViewWidth() - 6.0f - 256.0f - 2.0f * HEART_PADDING - 12.0f, 35.0f, 12.0f, 14.0f)
        
        // Draw spell card being played
        if this.playing_spell_order.has {
            // Playing spell order
            playing_spell_order_x float = calculatePlayingSpellOrderX(glfwGetTime() - this.playing_spell_order_start)
            
            if glfwGetTime() >= this.playing_spell_order_start + PLAYING_SPELL_ORDER_DURATION,
                this.playing_spell_order.rid()
            else {
                // TODO: Don't create a card instance for every frame?
                // Maybe it doesn't matter
                instance CardInstance = cardInstance(this.playing_spell_order.getPointer().blueprint)
                drawCard(&instance, playing_spell_order_x, captViewHeight() / 2.0f, HUGE_CARD_SCALE)
            }
        }
        
        // Draw friendly hand
        this.drawMyHand()
        
        // Draw alert message
        if this.alert.has, this.alert.getPointer().draw()
    }
    
    func drawMyHand {
        me *Player = this.state.getThisPlayer()
        this.getMyHandCardPositions(def card_positions <CardPosition> List)
        
        drawing_order <usize> List
        
        repeat card_positions.length {
            smallest_idx usize = 0
            smallest_scale float = 1000.0f
            each CardPosition in static card_positions {
                if drawing_order.contains(idx), continue
                if it.scale < smallest_scale {
                    smallest_idx = idx
                    smallest_scale = it.scale
                }
            }
            drawing_order.add(smallest_idx)
        }
        
        each card_idx usize in static drawing_order {
            instance *CardInstance = me.hand.getPointer(card_idx)
            
            if this.dragging_card == instance.instance_id {
                // If the card is being dragged, draw it where it's being dragged
                captMouseViewPosition(undef mouseX float, undef mouseY float)
                drawCard(instance, mouseX, mouseY, 1.0f /*this.dragging_card_scale*/)
                continue
            }
            
            position *CardPosition = card_positions.getPointer(card_idx)
            drawCard(instance, position.x, position.y, position.scale)
        }
    }
    
    func drawOpponentsHand {
        opponent *Player = this.state.getOpponent()
        unless opponent, return
        
        hand_count usize = opponent.hand.length
        
        x float = captViewWidth() / 2.0f - ((hand_count - 1) as float * CARD_XADVANCE + CARD_WIDTH) / 2.0f + CARD_WIDTH / 2.0f
        y float = 0.0f
        
        repeat hand_count {
            drawCentered(textures.standard_card_back, x, y, CARD_WIDTH, CARD_HEIGHT)
            x += CARD_WIDTH + CARD_PADDING
        }
    }
    
    func drawMyBoard {
        me *Player = this.state.getThisPlayer()
        unless me, return
        
        captMouseViewPosition(undef mouseX float, undef mouseY float)
        this.getMyBoardCardPositions(def card_positions <CardPosition> List)
        
        // Draw stat card
        if me.stat_card.has {
            this.getMyStatCardPosition(card_positions, undef stat_x float, undef stat_y float)
            drawCard(me.stat_card.getPointer(), stat_x, stat_y, 1.0f)
        }
        
        // Draw main board cards
        each CardPosition in card_positions {
            if glfwGetMouseButton(_captain_window, GLFW_MOUSE_BUTTON_2) == GLFW_PRESS && it.intersecting(mouseX, mouseY) {
                drawCard(me.board.getPointer(idx), it.x, it.y, it.scale)
            } else {
                this.drawCharacter(me.board.getPointer(idx), it)
            }
        }
    }
    
    func drawOpponentsBoard {
        opponent *Player = this.state.getOpponent()
        unless opponent, return
        
        captMouseViewPosition(undef mouseX float, undef mouseY float)
        this.getOpponentsBoardCardPositions(def card_positions <CardPosition> List)
        
        // Draw stat card
        if opponent.stat_card.has {
            this.getOpponentsStatCardPosition(card_positions, undef stat_x float, undef stat_y float)
            drawCard(opponent.stat_card.getPointer(), stat_x, stat_y, 1.0f)
        }
        
        // Draw main board cards
        each CardPosition in card_positions {
            if glfwGetMouseButton(_captain_window, GLFW_MOUSE_BUTTON_2) == GLFW_PRESS && it.intersecting(mouseX, mouseY) {
                drawCard(opponent.board.getPointer(idx), it.x, it.y, it.scale)
            } else {
                this.drawCharacter(opponent.board.getPointer(idx), it)
            }
        }
    }
    
    func getMyHandCardPositions(out card_positions *<CardPosition> List) {
        me *Player = this.state.getThisPlayer()
        unless me, return
        
        captMouseViewPosition(undef mouseX float, undef mouseY float)
        
        hand_count usize = me.hand.length
        if hand_count == 0, return
        
        x float = captViewWidth() / 2.0f - ((hand_count - 1) as float * CARD_XADVANCE + CARD_WIDTH) / 2.0f + CARD_WIDTH / 2.0f
        y float = captViewHeight() - CARD_HEIGHT / 6.0f - CARD_PADDING
        
        repeat hand_count {
            mouse_distance_factor float = distance(mouseX + (mouseX - x) / 2.0f, mouseY, x, y)
            if mouse_distance_factor < CARD_HEIGHT / 2.0f, mouse_distance_factor = CARD_HEIGHT / 2.0f
            
            scale float = mouse_distance_factor > CARD_HEIGHT ? 1.0f : 1.0f + (CARD_HEIGHT - mouse_distance_factor) as float / CARD_HEIGHT as float
            y_offset float = mouse_distance_factor > CARD_HEIGHT ? 0.0f : scale * 0.6 * CARD_HEIGHT * (CARD_HEIGHT - mouse_distance_factor) as float / CARD_HEIGHT as float
            
            card_positions.add(cardPosition(x, y  - y_offset, y, scale))
            x += CARD_WIDTH + CARD_PADDING
        }
    }
    
    func getMyBoardCardPositions(out card_positions *<CardPosition> List) {
        me *Player = this.state.getThisPlayer()
        unless me, return
        
        board_count usize = me.board.length
        if board_count == 0, return
        
        x float = captViewWidth() / 2.0f - ((board_count - 1) as float * CARD_XADVANCE + CARD_WIDTH) / 2.0f + CARD_WIDTH / 2.0f
        y float = captViewHeight() / 2.0f + (MANA_HEIGHT / 2.0f + MANA_PADDING + CARD_HEIGHT / 2.0f) + CARD_GAME_VERTICAL_OFFSET
        
        repeat board_count {
            card_positions.add(cardPosition(x, y, y, 1.0f))
            x += CARD_WIDTH + CARD_PADDING
        }
    }
    
    func getOpponentsBoardCardPositions(out card_positions *<CardPosition> List) {
        opponent *Player = this.state.getOpponent()
        unless opponent, return
        
        board_count usize = opponent.board.length
        if board_count == 0, return
        
        x float = captViewWidth() / 2.0f - ((board_count - 1) as float * CARD_XADVANCE + CARD_WIDTH) / 2.0f + CARD_WIDTH / 2.0f
        y float = captViewHeight() / 2.0f - (MANA_HEIGHT / 2.0f + MANA_PADDING + CARD_HEIGHT / 2.0f) + CARD_GAME_VERTICAL_OFFSET
        
        repeat board_count {
            card_positions.add(cardPosition(x, y, y, 1.0f))
            x += CARD_WIDTH + CARD_PADDING
        }
    }
    
    func drawCharacter(instance *CardInstance, position CardPosition) {
        texture *CaptTexture = null
        now double = glfwGetTime()
        
        status CardStatus = this.card_statuses.getFromNetworkID(instance.network_id)
        has_died bool = status.is_dead
        has_been_sad bool = status.is_sad
        has_been_on_fire bool = status.is_on_fire
        has_been_on_eternal_fire bool = status.is_on_eternal_fire
        has_been_dancing bool = status.is_dancing
        has_been_bleeding bool = status.is_bleeding
        has_been_tripped bool = status.is_tripped
        h_scale float = 1.0f
        
        if glfwGetTime() - instance.when_created <= 0.1 {
            switch cast int (40.0 * (glfwGetTime() - instance.when_created)) {
            case 0, texture = &textures.spawn1; h_scale = 2.0f
            case 1, texture = &textures.spawn2; h_scale = 1.5f
            case 2, texture = &textures.spawn3
            default texture = &textures.spawn4
            }
        } else if has_been_dancing {
            texture = now % 1.0 < 0.5 ? instance.ct.stand1 : instance.ct.cheer
        } else if this.card_animations.hasCardAnimation(instance.network_id, undef animation CardAnimation) {
            texture = animation.texture
        } else if has_been_tripped {
            texture = now % 1.0 < 0.5 ? instance.ct.stand1 : instance.ct.die
        } else if has_been_sad {
            texture = now % 1.0 < 0.5 ? instance.ct.sad1 : instance.ct.sad2
        } else {
            texture = now % 1.0 < 0.5 ? instance.ct.stand1 : instance.ct.stand2
        }
        
        if has_been_on_eternal_fire {
            // Draw behind eternal flames
            drawCentered(textures.fire_debuff_blue_hr, position.x, position.y, 2.0f * position.scale * CHARACTER_WIDTH, 2.0f * position.scale * CHARACTER_HEIGHT)
        } else if has_been_on_fire {
            // Draw behind flames
            drawCentered(textures.fire_debuff_hr, position.x, position.y, 2.0f * position.scale * CHARACTER_WIDTH, 2.0f * position.scale * CHARACTER_HEIGHT)
        }
        
        if has_died, captDrawOpacity(0.5f)
        drawCentered(*texture, position.x, position.y, position.scale * CHARACTER_WIDTH, h_scale * position.scale * CHARACTER_HEIGHT)
        if has_died, captDrawOpacity(1.0f)
        
        if status.is_raging {
            // Draw rage symbol if raging
            drawCentered(now % 1.0 < 0.5 ? textures.rage1 : textures.rage2, position.x, position.y, position.scale * CHARACTER_WIDTH, position.scale * CHARACTER_HEIGHT)
        }
        
        if has_been_bleeding {
            // Draw in front blood
            drawCentered(now % 1.0 < 0.5 ? textures.bleeding1 : textures.bleeding2, position.x, position.y, position.scale * CHARACTER_WIDTH, position.scale * CHARACTER_HEIGHT)
        }
        
        if has_been_on_eternal_fire {
            // Draw in front for eternal fire
            fire CaptTexture = now % 1.0 < 0.5 ? (now % 1.0 < 0.25 ? textures.blue_fire1 : textures.blue_fire2) : (now % 1.0 < 0.75 ? textures.blue_fire3 : textures.blue_fire4)
            drawCentered(fire, position.x, position.y, position.scale * CHARACTER_WIDTH, position.scale * CHARACTER_HEIGHT)
        } else if has_been_on_fire {
            // Draw in front for fire
            fire CaptTexture = now % 1.0 < 0.5 ? (now % 1.0 < 0.25 ? textures.fire1 : textures.fire2) : (now % 1.0 < 0.75 ? textures.fire3 : textures.fire4)
            drawCentered(fire, position.x, position.y, position.scale * CHARACTER_WIDTH, position.scale * CHARACTER_HEIGHT)
        }
        
        this.drawParticlesForCard(instance.network_id, position)
    }
    
    func drawMana(center_x, center_y float, count int) {
        if count < 0,  print("ERROR: CardGame.drawMana() got mana less than 0"); return
        if count == 0, return
        
        total_width float = (count - 1) as float * MANA_XADVANCE + MANA_WIDTH
        x_offset float = 0.0f - total_width / 2.0f
        
        //if this.alert.has {
        //    captDrawOpacity(this.alert.getPointer().getAmountAwayFromCenter())
        //}
        
        if this.playing_wizards_aid_animation {
            now double = glfwGetTime()
            
            if this.wizards_aid_animation_beginning == 0.0 {
                this.wizards_aid_animation_beginning = now
            }
            
            // TODO: Maybe store texture list into array or something
            // that lives for the duration of the program
            wizards_aid_texture *CaptTexture
            switch cast int (7.0 * 1.5 * (now - this.wizards_aid_animation_beginning)) {
            case 0, wizards_aid_texture = &textures.wizards_aid1
            case 1, wizards_aid_texture = &textures.wizards_aid2
            case 2, wizards_aid_texture = &textures.wizards_aid3
            case 3, wizards_aid_texture = &textures.wizards_aid4
            case 4, wizards_aid_texture = &textures.wizards_aid5
            case 5, wizards_aid_texture = &textures.wizards_aid6
            case 6, wizards_aid_texture = &textures.wizards_aid7
            default wizards_aid_texture = &textures.wizards_aid7
            }
            
            drawCentered(*wizards_aid_texture, center_x, center_y, MANA_WIDTH, MANA_HEIGHT)
            
            if this.wizards_aid_animation_beginning + 0.6666666666667 <= now {
                this.playing_wizards_aid_animation = false
            }
        } else repeat count {
            captDrawTexture(textures.mana, center_x + x_offset, center_y - MANA_HEIGHT / 2.0f, MANA_WIDTH, MANA_HEIGHT)
            x_offset += MANA_XADVANCE
        }
        
        captDrawOpacity(1.0f)
    }
    
    func drawHearts(center_x, center_y float, count int) {
        if count < 0,  print("ERROR: CardGame.drawHearts() got hearts less than 0"); return
        if count == 0, return
        
        total_width float = (count - 1) as float * HEART_XADVANCE + HEART_WIDTH
        x_offset float = 0.0f - total_width / 2.0f
        
        repeat count {
            captDrawTexture(textures.heart, center_x + x_offset, center_y - HEART_HEIGHT / 2.0f, HEART_WIDTH, HEART_HEIGHT)
            x_offset += HEART_XADVANCE
        }
    }
    
    func displayAlert(message String) {
        this.alert.set(gameAlert(message))
    }
    
    func getEndTurnButtonPosition(out x, y *float) {
        *x = captViewWidth() / 2.0f + 16.0f
        *y = captViewHeight() / 2.0f + 32.0f / 2.0f + MANA_PADDING + CARD_HEIGHT / 2.0f + HEART_HEIGHT / 2.0f + HEART_PADDING - 16.0f
    }
    
    func calculateWhetherEndTurnButtonIsHovered(mouseX, mouseY float) bool {
        this.is_end_turn_button_hovered = isButtonHovered(this, func &getEndTurnButtonPosition(*CardGame, *float, *float), mouseX, mouseY)
        return this.is_end_turn_button_hovered
    }
    
    func getDrawCardButtonPosition(out x, y *float) {
        *x = captViewWidth() / 2.0f - MAIN_MENU_BUTTON_WIDTH - 16.0f
        *y = captViewHeight() / 2.0f + 32.0f / 2.0f + MANA_PADDING + CARD_HEIGHT / 2.0f + HEART_HEIGHT / 2.0f + HEART_PADDING - 16.0f
    }
    
    func calculateWhetherDrawCardButtonIsHovered(mouseX, mouseY float) bool {
        this.is_draw_card_button_hovered = isButtonHovered(this, func &getDrawCardButtonPosition(*CardGame, *float, *float), mouseX, mouseY)
        return this.is_draw_card_button_hovered
    }
    
    func getMyCardPositionFromNetworkID(network_id CardNetworkID, out position *CardPosition) successful {
        // Brute force find position of one of our cards by network id
        me *Player = this.state.getThisPlayer()
        unless me, return false
        
        each CardInstance in me.board {
            if it.network_id == network_id {
                this.getMyBoardCardPositions(def card_positions <CardPosition> List)
                *position = card_positions.get(idx)
                return true
            }
        }
        
        return false
    }
    
    func getOpponentCardPositionFromNetworkID(network_id CardNetworkID, out position *CardPosition) successful {
        // Brute force find position of one of our cards by network id
        opponent *Player = this.state.getOpponent()
        unless opponent, return false
        
        each CardInstance in opponent.board {
            if it.network_id == network_id {
                this.getOpponentsBoardCardPositions(def card_positions <CardPosition> List)
                *position = card_positions.get(idx)
                return true
            }
        }
        
        return false
    }
    
    func getBoardCardPositions(out network_ids *<CardNetworkID> List, out positions *<CardPosition> List) {
        me *Player = this.state.getThisPlayer()
        opponent *Player = this.state.getOpponent()
        
        this.getMyBoardCardPositions(def my_positions <CardPosition> List)
        this.getOpponentsBoardCardPositions(def opponents_positions <CardPosition> List)
        
        if me, each CardPosition in my_positions {
            network_ids.add(me.board.getPointer(idx).network_id)
            positions.add(it)
        }
        
        if opponent, each CardPosition in opponents_positions {
            network_ids.add(opponent.board.getPointer(idx).network_id)
            positions.add(it)
        }
    }
    
    func getMyCardUnderneath(mouseX, mouseY float) *CardInstance {
        me *Player = this.state.getThisPlayer()
        unless me, return null
        
        this.getMyBoardCardPositions(def card_positions <CardPosition> List)
        
        each CardPosition in card_positions {
            if it.intersecting(mouseX, mouseY), return me.board.getPointer(idx)
        }
        
        return null
    }
    
    func getOpponentCardUnderneath(mouseX, mouseY float) *CardInstance {
        opponent *Player = this.state.getOpponent()
        unless opponent, return null
        
        this.getOpponentsBoardCardPositions(def card_positions <CardPosition> List)
        
        each CardPosition in card_positions {
            if it.intersecting(mouseX, mouseY), return opponent.board.getPointer(idx)
        }
        
        return null
    }
    
    func endTurn {
        this.endTurn(this.state.getThisPlayer(), &this.attack_orders)
    }
    
    func endTurn(player *Player, player_attack_orders *<AttackOrder> List) {
        if player == null || player.done || player.sent_done || this.state.isGameOver(), return
        
        if this.state.phase.kind == PhaseKind::ATTACK && player_attack_orders != null {
            // If ending attack phase, send attack orders for battlephase
            each AttackOrder in static *player_attack_orders,
                gamedata.manager.writeOutgoing(player.name + "@attack " + toString(it.aggressor) + " " + toString(it.victim) + " `\n")
        }
        
        gamedata.manager.writeOutgoing(player.name + "@end\n")
        player.sent_done = true
        
        is_me bool = player.name == gamedata.player_name
        if is_me, this.show_end_turn_button = false
    }
    
    func drawParticlesForCard(network_id CardNetworkID, position CardPosition) {
        each *CardParticle in this.particles {
            if it.network_id == network_id {
                drawCentered(*it.texture, position.x, position.y + position.scale * it.y_offset, position.scale * it.width, position.scale * it.height)
            }
        }
    }
    
    func getMyStatCardPosition(in board_positions <CardPosition> List, out x *float, out y *float) {
        if board_positions.length > 0 {
            *x = board_positions.getPointer(0).x - CARD_PADDING - CARD_WIDTH
            *y = board_positions.getPointer(0).y
            return
        }
        
        *x = captViewWidth() / 2.0f
        *y = captViewHeight() / 2.0f + (MANA_HEIGHT / 2.0f + MANA_PADDING + CARD_HEIGHT / 2.0f) + CARD_GAME_VERTICAL_OFFSET
        return
    }
    
    func getOpponentsStatCardPosition(in board_positions <CardPosition> List, out x *float, out y *float) {
        if board_positions.length > 0 {
            *x = board_positions.getPointer(0).x - CARD_PADDING - CARD_WIDTH
            *y = board_positions.getPointer(0).y
            return
        }
        
        *x = captViewWidth() / 2.0f
        *y = captViewHeight() / 2.0f - (MANA_HEIGHT / 2.0f + MANA_PADDING + CARD_HEIGHT / 2.0f) + CARD_GAME_VERTICAL_OFFSET
        return
    }
    
    func playAnimation(animation *CardAnimation) {
        // NOTE: Takes ownership of 'animation *CardAnimation'
        animation.start = glfwGetTime()
        this.card_animations.add(animation)
    }
    
    func scheduleAnimation(animation *CardAnimation, from_now_in_seconds double) {
        // NOTE: Takes ownership of 'animation *CardAnimation'
        this.scheduled_animations.add(scheduledCardAnimation(animation, glfwGetTime() + from_now_in_seconds))
    }
    
    func clearAnimations {
        each *CardAnimation in this.card_animations {
            it.deleteChildren()
            delete it
        }
        this.card_animations.length = 0
    }
    
    func clearScheduledAnimations {
        each ScheduledCardAnimation in this.scheduled_animations {
            it.animation.deleteChildren()
            delete it.animation
        }
        this.scheduled_animations.length = 0
    }
    
    func clearAllAnimations {
        this.clearAnimations()
        this.clearScheduledAnimations()
    }
    
    func playScheduledAnimations {
        each ScheduledCardAnimation in this.scheduled_animations {
            unless it.shouldStart(), continue
            
            this.playAnimation(it.animation)
            this.scheduled_animations.remove(idx--)
        }
    }
    
    func playAttackAnimation(aggressor *CardInstance, victim *CardInstance, did_attack_work successful, is_friendly bool) {
        this.scheduleAnimation(aggressor.newAttackAnimation(), 0.5)
        this.scheduleAnimation(is_friendly ?
                victim.newCheerAnimation()
            : (
                did_attack_work ? (victim.isDead() ? victim.newDieAnimation() : victim.newHurtAnimation()) : victim.newMockAnimation()
            )
        , 1.5)
    }
    
    func clearParticles {
        each *CardParticle in this.particles {
            it.deleteChildren()
            delete it
        }
        this.particles.length = 0
    }
    
    func playWizardsAidAnimation {
        this.playing_wizards_aid_animation = true
        this.wizards_aid_animation_beginning = 0.0
    }
    
    func processAI {
        ai *Player = this.state.getPlayer(gamedata.ai_name)
        human *Player = this.state.getThisPlayer()
        ai_attack_orders <AttackOrder> List
        
        unless ai,    print("ERROR: performAI() failed to find AI player"); return
        unless human, print("ERROR: performAI() failed to find human player"); return
        
        // Make AI leave the game if defeated
        if ai.hearts <= 0 {
            // Loopback leave message, since network is being emulated
            gamedata.manager.writeOutgoing(gamedata.ai_name + "$leave\n")
            return
        }
        
        if !ai.sent_done && this.state.phase.kind == PhaseKind::SPAWN, repeat count_loop_through_hand : 2, repeat ai.hand.length {
            possible_card *CardInstance = ai.hand.getPointer(idx)
            
            // Make sure we can afford to play this card
            if ai.getDiscountedCardCost(possible_card.cost) > ai.mana && !meets(gamedata.ai_difficulty, AIDifficulty::CHEATER), continue
            
            cost int = ai.getDiscountedCardCost(possible_card.cost)
            
            // Cheater only pays card cost half of the time
            if meets(gamedata.ai_difficulty, AIDifficulty::CHEATER) && random(2) == 0, cost = 0
            
            if meets(gamedata.ai_difficulty, AIDifficulty::MEDIUM) && possible_card.kind == CardKind::SPELL && random(100) < 50 {
                // Play spell card
                play_command String = possible_card.traits.urgent ? "@playnow " : "@play "
                
                target_board *<CardInstance> List = possible_card.traits.ai_usage.kind == AIUsageKind::OFFENSIVE ? &human.board : &ai.board
                
                if !possible_card.traits.requires_target || target_board.length != 0 {
                    target usize = 0
                    if possible_card.traits.requires_target, target = target_board.getRandomPointer().network_id
                    gamedata.manager.writeOutgoing(gamedata.ai_name + play_command + possible_card.name + " " + toString(target) + " `\n")
                    
                    ai.mana -= cost
                    ai.mana = max(ai.mana, 0)
                    ai.hand.remove(idx--)
                    
                    // Restart from beginning of hand, since this card changes costs
                    if possible_card.traits.thrift != 0, idx = 0
                }
            } else if possible_card.kind == CardKind::CREATURE && (ai.board.length < /*TODO REMOVED HARDCODED*/ 4 || meets(gamedata.ai_difficulty, AIDifficulty::CHEATER)) {
                // Play creature card
                gamedata.manager.writeOutgoing(gamedata.ai_name + "@spawn ~ " + possible_card.name + " rightof 0\n")
                ai.mana -= cost
                ai.mana = max(ai.mana, 0)
                ai.hand.remove(idx--)
                
                // Only play one creature card at a time if easy mode
                if gamedata.ai_difficulty == AIDifficulty::EASY, break count_loop_through_hand
            } else if possible_card.kind == CardKind::STAT && meets(gamedata.ai_difficulty, AIDifficulty::HARD) && random(100) < 33 && ai.board.length != 0 {
                // Play stat cards
                gamedata.manager.writeOutgoing(gamedata.ai_name + "@spawn ~ " + possible_card.name + " rightof 0\n")
                ai.mana -= cost
                ai.mana = max(ai.mana, 0)
                ai.hand.remove(idx--)
            } else if possible_card.kind == CardKind::TRAP && meets(gamedata.ai_difficulty, AIDifficulty::HARD) && random(100) < 33 && ai.board.length != 0 {
                // Play trap cards
                target CardNetworkID = ai.board.getRandomPointer().network_id
                gamedata.manager.writeOutgoing(gamedata.ai_name + "@trap " + possible_card.name + " " + toString(target) + "\n")
                ai.mana -= cost
                ai.mana = max(ai.mana, 0)
                ai.hand.remove(idx--)
            }
        }
        
        if !ai.sent_done && this.state.phase.kind == PhaseKind::ATTACK && human.board.length != 0 && this.state.global_dancing == 0 {
            must_attack_first_id CardNetworkID = 0
            
            // Attack the first card that "must be attacked first"
            each CardInstance in static human.board {
                if it.traits.must_be_attacked_first, must_attack_first_id = it.network_id; break
            }
            
            each CardInstance in ai.board, repeat static it.traits.attacks {
                if it.isDancing() || it.isDead() || it.traits.tripped, continue
                
                target_network_id CardNetworkID = 0
                
                if must_attack_first_id {
                    // Attack the required first target
                    target_network_id = must_attack_first_id
                } else {
                    random_target *CardInstance = human.board.getRandomPointer()
                    
                    // Attempt to not attack a 'must be attacked last' card or a dead card
                    repeat 10 {
                        unless random_target.traits.must_be_attacked_last || random_target.isDead(), break
                        random_target = human.board.getRandomPointer()
                    }
                    
                    target_network_id = random_target.network_id
                }
                
                ai_attack_orders.add(attackOrder(it.network_id, target_network_id, random(100), false))
            }
        }
        
        this.endTurn(ai, &ai_attack_orders)
    }
}

func drawCard(instance *CardInstance, x_focus, y_focus, scale float) {
    // NOTE: We can afford to call this ~50 times per frame
    
    top float = y_focus - scale * CARD_HEIGHT / 2.0f
    left float = x_focus - scale * CARD_WIDTH / 2.0f
    width float = scale * CARD_WIDTH
    height float = scale * CARD_HEIGHT
    
    // Standard Info
    //captDrawTexture(textures.standard_info, left + width, top, scale * CARD_INFO_WIDTH, scale * CARD_INFO_HEIGHT)
    
    captDrawTexture(instance.getStandardCardTexture(), left, top, width, height)
    
    // Draw Cost
    drawText(toString(instance.cost), left + width * 0.025, top + width * 0.028, textures.font_black, scale * 12.0f)
    
    // Draw Title
    title_offset float = instance.title.first('\n'ub) != -1sl ? width * 0.05 : width * 0.09
    drawText(instance.title, left + width * 0.25, top + title_offset, textures.font_black, scale * 4.0f)
    
    // Draw Picture
    captDrawTexture(*instance.ct.portrait, left, top + scale * CARD_PICTURE_Y_OFFSET, width, scale * CARD_PICTURE_HEIGHT)
    captDrawTexture(textures.picture_frame, left, top + scale * CARD_PICTURE_Y_OFFSET, width, scale * CARD_PICTURE_HEIGHT)
    
    // Draw Description
    description_offset float = width * 0.79
    drawText(instance.description, left + width * 0.05, top + description_offset, textures.font_black, scale * 4.0f)
    
    // Draw Offense
    offense_texture *CaptTexture = instance.offense.getTexture()
    if offense_texture {
        captDrawTexture(*offense_texture, left + width * 0.04, top + height * 0.85, scale * CARD_ELEMENT_WIDTH, scale * CARD_ELEMENT_HEIGHT)
        
        // Draw Attack #
        attack_string String = toString(instance.attack)
        attack_number_alignment float = attack_string.length < 2 ? 2.5f : 0.0f
        drawText(attack_string, left + width * 0.27 + scale * attack_number_alignment, top + height * 0.87, textures.font_black, scale * 8.0f)
    }
    
    // Draw Defense
    defense_texture *CaptTexture = instance.defense.getTexture()
    if defense_texture {
        captDrawTexture(*defense_texture, left + width - scale * CARD_ELEMENT_WIDTH - width * 0.04, top + height * 0.85, scale * CARD_ELEMENT_WIDTH, scale * CARD_ELEMENT_HEIGHT)
        
        // Draw Defense #
        hp_string String = instance.hp <= 0 ? "0" : toString(instance.hp)
        hp_number_alignment float = hp_string.length < 2 ? 3.5f : 0.0f
        drawText(hp_string, left + width * 0.535 + scale * hp_number_alignment, top + height * 0.87, textures.font_black, scale * 8.0f)
    }
}

func calculatePlayingSpellOrderX(elapsed_time_since double) float {
    start float = captViewWidth() + 2.0f * CARD_WIDTH * HUGE_CARD_SCALE
    end float = 0.0f - 2.0f * CARD_WIDTH * HUGE_CARD_SCALE
    
    x float = lerpInverseSigmoid(start, end, elapsed_time_since as float / PLAYING_SPELL_ORDER_DURATION)
    return x
}

func lerp(x1, x2 float, percent float) float {
    return x1 + (x2 - x1) * percent
}

func lerpSigmoid(x1, x2 float, percent float, consistency float = 0.01f) float {
    // xdiff(percent) = {x2-x1}*\frac{percent}{\sqrt{0.01+percent^{2}}}
    return x1 + (x2 - x1) * percent / (sqrtf(consistency + percent * percent))
}

func lerpInverseSigmoid(x1, x2 float, percent float, consistency float = 300.0f) float {
    // First half of curve: -\sqrt{-\frac{\left(\left(2x-1\right)\right)^{2}}{300\left(\left(2x-1\right)^{2}-1\right)}}+0.5
    // Second half of curve: \sqrt{-\frac{\left(2x-1\right)^{2}}{300\left(\left(2x-1\right)^{2}-1\right)}}+0.5
    
    numerator_root float = 2.0f * percent - 1.0f
    numerator float =  numerator_root * numerator_root
    denominator float = consistency * (numerator - 1.0f)
    return x1 + (x2 - x1) * (0.5f + (percent <= 0.5 ? -1.0f : 1.0f) * sqrtf(-1.0f * numerator / denominator))
}
