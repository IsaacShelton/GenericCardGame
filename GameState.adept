
import 'main.adept'
import 'Card.adept'
import 'Deck.adept'
import 'Phase.adept'
import 'CardStatus.adept'
import 'SpellOrder.adept'
import 'AttackOrder.adept'

alias PlayerID = usize

struct Player (
    player_id PlayerID,
    name String,
    starting_hearts, hearts, mana, supply, draw_cost int,
    hand <CardInstance> List,
    board <CardInstance> List,
    stat_card <CardInstance> Optional,
    done, sent_done bool
) {
    func drawCardsFromDeck(amount usize, is_me bool) {
        repeat amount {
            // Maximum hand limit of 10 cards for now
            if this.hand.length >= 10, return
            
            card CardInstance = gamedata.deck.randomCard()
            
            #if enable_debugging_hotkeys
            if glfwGetKey(_captain_window, GLFW_KEY_RIGHT_SHIFT) == GLFW_PRESS {
                card = gamedata.deck.getCardByName(glfwGetKey(_captain_window, GLFW_KEY_LEFT_CONTROL) == GLFW_PRESS ? "isaacs_mixtape" : "paper_airplane")
            }
            #end
            
            // Try to avoid redrawing cards
            if is_me, repeat redrawing : 10 {
                each CardInstance in this.hand {
                    if it.name == card.name {
                        card = gamedata.deck.randomCard()
                        continue redrawing
                    }
                }
                break
            }
            
            this.hand.add(card)
        }
    }
    
    func spawnCard(blueprint_name String, unique_network_id CardNetworkID, relation String, related_unique_network_id CardNetworkID,
            out particles *<*CardParticle> List, is_me bool, global_dancing int) {
        destination usize = 0
        
        blueprint *CardBlueprint = gamedata.deck.getCardBlueprint(blueprint_name)
        unless blueprint {
            print("ERROR: GameState.spawnCard() failed to find card blueprint for '%'" % blueprint_name)
            return
        }
        
        // Handle if the card is a stat card
        if blueprint.kind == CardKind::STAT {
            // Bypass normal spawning process if it's a stat card
            this.stat_card.rid()
            
            // Manually set stat card
            if this.stat_card.has, this.stat_card.value.?__defer__()
            this.stat_card.value = cardInstance(blueprint)
            this.stat_card.has = true
            return
        }
        
        // Find where to put the creature card
        if related_unique_network_id != 0, each CardInstance in static this.board {
            if it.network_id == related_unique_network_id {
                destination = relation == "leftof" ? idx : idx + 1
                break
            }
        }
        
        this.board.insert(destination, cardInstance(blueprint))
        
        card *CardInstance = this.board.getPointer(destination)
        card.assignNetworkID(unique_network_id)
        
        // Apply battlecry-adjacent
        if card.traits.battlecry_adjacent != 0 {
            left *CardInstance = destination == 0 ? null as *CardInstance : this.board.getPointer(destination - 1)
            right *CardInstance = destination + 1 == this.board.length ? null as *CardInstance : this.board.getPointer(destination + 1)
            
            if left {
                left.attack  += card.traits.battlecry_adjacent
                if particles, particles.addAttackBonus(left.network_id)
            }
            if right {
                right.attack += card.traits.battlecry_adjacent
                if particles, particles.addAttackBonus(right.network_id)
            }
        }
        
        // Apply global_dancing
        if global_dancing > 0 && global_dancing > card.traits.dancing {
            card.traits.dancing = global_dancing
        }
        
        // Don't keep track for supply of ourselves here, because it depends on the network
        unless is_me || blueprint.traits.separation {
            this.supply++
        }
    }
    
    func getCardOnBoardByNetworkId(network_id CardNetworkID) *CardInstance {
        each CardInstance in this.board, if it.network_id == network_id, return &it
        return null
    }
    
    func addCardStatusesToList(out list_to_add_to *<CardStatus> List) {
        each CardInstance in this.board, list_to_add_to.add(cardStatus(&it))
    }
    
    func removeDeadCards(is_me bool) {
        // NOTE: 'is_me' is whether this player is the "actual" player
        each CardInstance in this.board, if it.isDead() {
            unless it.traits.separation, this.supply--
            
            if it.traits.recycle, this.drawCardsFromDeck(it.traits.recycle, is_me)
            
            this.board.remove(idx--)
        }
    }
    
    func getDrawCost int {
        unless this.stat_card.has, return this.draw_cost
        
        discount int = this.stat_card.getPointer().traits.draw_cost_reduction != 0
        if discount != 0 {
            return discount >= this.draw_cost ? 1 : this.draw_cost - discount
        }
        
        return this.draw_cost
    }
}

func addPlayer(this *<Player> List, player_id PlayerID, name String) *Player {
    unless this.add(), return null
    
    new_player *Player = this.items at (this.length - 1)
    new_player.player_id = player_id
    new_player.name = name.clone()
    new_player.starting_hearts = 3
    new_player.hearts = 3
    new_player.mana = 0
    new_player.supply = 0
    new_player.draw_cost = 2
    // new_player.hand is left empty
    // new_player.board is left empty
    // new_player.stat_card is left with nothing
    new_player.done = false
    return new_player
}

struct GameState (
    phase Phase,
    next_player_id PlayerID,
    global_mana int,
    global_dancing int,
    players <Player> List,
    spell_orders <SpellOrder> List,
    attack_orders <AttackOrder> List
) {
    func init(player_names <String> List) {
        this.phase = phase(PhaseKind::SPAWN)
        this.next_player_id = 1
        this.global_mana = player_names.length
        this.global_dancing = 0
        
        this.players.clear()
        each player_name String in player_names, this.addPlayer(player_name)
        this.attack_orders.clear()
        
        this.distributeMana()
    }
    
    func addPlayer(name String) {
        new_player *Player = this.players.addPlayer(this.next_player_id++, name)
        new_player.drawCardsFromDeck(3, name == gamedata.player_name)
    }
    
    func getPlayer(name String) *Player {
        each Player in this.players, if it.name == name, return &it
        
        print("ERROR: GameState.getPlayer(String) failed to find player '%'" % name)
        print("       (returning null)")
        return null
    }
    
    func getPlayer(player_id PlayerID) *Player {
        each Player in this.players, if it.player_id == player_id, return &it
        
        print("ERROR: GameState.getPlayer(PlayerID) failed to find player %" % player_id)
        print("       (returning null)")
        return null
    }
    
    func getThisPlayer *Player = this.getPlayer(gamedata.player_name)
    
    func getMyCard(instance_id CardInstanceID) *CardInstance {
        me *Player = this.getThisPlayer()
        unless me, return null
        
        each CardInstance in me.hand,
            if it.instance_id == instance_id, return &it
        
        return null
    }
    
    func getRidOfMyCardInHand(instance_id CardInstanceID) successful {
        me *Player = this.getThisPlayer()
        unless me, return false
        
        each CardInstance in me.hand {
            if it.instance_id == instance_id {
                me.hand.remove(idx)
                return true
            }
        }
        
        return false
    }
    
    func getOpponent *Player {
        each Player in this.players, unless it.name == gamedata.player_name, return &it
        
        print("ERROR: GameState.getOpponent() failed to find opponent")
        print("       (returning null)")
        return null
    }
    
    func getCardOnBoardByNetworkId(network_id CardNetworkID) *CardInstance {
        each player Player in static this.players {
            instance *CardInstance = player.getCardOnBoardByNetworkId(network_id)
            if instance, return instance
        }
        return null
    }
    
    func willAdvancePhase bool {
        if this.players.length == 0, return false
        each Player in this.players, unless it.done, return false
        return true
    }
    
    func shouldAdvancePhase bool {
        unless this.willAdvancePhase(), return false
        
        this.phase.advance()
        each Player in this.players, it.done = false; it.sent_done = false
        
        switch this.phase.kind {
        case PhaseKind::SPAWN
            this.distributeMana()
             this.reduceTimedEffects()
        }
        
        if this.phase.kind != PhaseKind::BATTLE,
            this.attack_orders.clear()
        
        // attack-equals-hp
        each player Player in this.players, each CardInstance in player.board, if it.traits.attack_equals_hp {
            it.attack = it.hp
        }
        
        return true
    }
    
    func distributeMana {
        if gamedata.gamemode.exclusive_heart_mana_bonus {
            each Player in this.players, it.mana = this.global_mana + (it.hearts <= it.starting_hearts ? it.starting_hearts - it.hearts : 0)
        } else {
            each Player in this.players, it.mana = this.global_mana
        }
    }
    
    func doDrawPhase {
        each Player in this.players {
            cards_to_draw usize = it.starting_hearts < it.hearts ? 1 : it.starting_hearts - it.hearts + 1
            it.drawCardsFromDeck(cards_to_draw, it.name == gamedata.player_name)
        }
    }
    
    func doAttack(aggressor *CardInstance, inout victim_var **CardInstance, out particles *<*CardParticle> List, randomness int) successful {
        used_shield bool = false
        victim *CardInstance = *victim_var
        attack int = aggressor.attack
        aggressor_owner *Player = this.findOwner(aggressor.network_id)
        victim_owner *Player = this.findOwner(victim.network_id)
        
        // dancing => You can't attack while dancing!
        if aggressor.traits.dancing, return false
        
        // random-victim
        if aggressor.traits.random_victim {
            // TODO: Make victim determination less correlated with other random events
            if victim_owner {
                *victim_var = victim_owner.board.getPointer(randomness % victim_owner.board.length)
                victim = *victim_var
            }
        }
        
        // rage
        if aggressor.traits.rage {
            // TODO: Make victim determination less correlated with other random events
            if victim_owner && victim_owner.board.length > 1 {
                initial_victim_index usize = 0
                
                // Find index which initial victim is holding
                each CardInstance in static victim_owner.board {
                    if it.network_id == victim.network_id {
                        initial_victim_index = idx
                        break
                    }
                }
                
                // Select a victim that isn't the target
                new_victim_index usize = randomness % (victim_owner.board.length - 1)
                if new_victim_index >= initial_victim_index, new_victim_index++
                
                *victim_var = victim_owner.board.getPointer(new_victim_index)
                victim = *victim_var
            }
            
            attack = cast int (attack as double * 1.5)
        }
        
        // can-heal
        if aggressor.traits.can_heal && aggressor_owner == victim_owner {
            victim.heal(aggressor.attack)
            if particles, particles.addHealing(victim.network_id)
            return true
        }
        
        // applies-resistance (stat card effect)
        if victim_owner && victim_owner.stat_card.has && victim_owner.stat_card.getPointer().traits.applies_resistance {
            attack -= victim_owner.stat_card.getPointer().traits.applies_resistance
            if attack < 0, attack = 0
            
            if particles, particles.addResistance(victim.network_id)
        }
        
        invulnerable_to_attack bool = (
            (victim.traits.invulnerable_to_blunt && aggressor.offense.kind == OffenseKind::BLUNT) ||
            (victim.traits.resistant_over != 0 && attack > victim.traits.resistant_over)
        )
        
        // Make victim invulnerable if must be attacked last and not the last card
        if victim.traits.must_be_attacked_last && !invulnerable_to_attack {
            is_last bool = true
            if victim_owner, each CardInstance in static victim_owner.board {
                unless it.traits.must_be_attacked_last || it.isDead(), is_last = false; break
            }
            unless is_last, invulnerable_to_attack = true
        }
        
        if invulnerable_to_attack {
            // For now, let's just act that since we are invulnerable to attack,
            // Nothing else from the attack applies
            return false
        }
        
        if victim.traits.shield > 0 {
            victim.traits.shield--
            
            if particles, particles.addPopupShield(victim.network_id)
            used_shield = true
            
            // For now, let's just act that since the shield came into play,
            // Nothing else from the attack applies
            return false
        }
        
        if victim.traits.endure > 0 && victim.hp > 0 && attack >= victim.hp && victim.hp > victim.traits.endure {
            // Endure
            victim.hp = victim.traits.endure
        } else {
            // Regular damage
            victim.hp -= attack
        }
        
        // Spread fire to victim if should
        if aggressor.traits.spreads_fire && !victim.traits.fire_resistant {
            if randomness < aggressor.traits.spreads_fire,
                victim.traits.on_fire = true
        }
        
        if aggressor.traits.flimsy {
            aggressor.hp -= aggressor.traits.flimsy
        }
        
        return true
    }
    
    func doSpell(player_id PlayerID, blueprint *CardBlueprint, victim *CardInstance, out particles *<*CardParticle> List, randomness int) successful {
        player *Player = this.getPlayer(player_id)
        
        // applies-shield (for spells)
        if blueprint.traits.applies_shield && victim {
            victim.traits.shield += blueprint.traits.applies_shield
            if particles, particles.addPopupShield(victim.network_id)
        }
        
        // applies-healing (for spells)
        if blueprint.traits.applies_healing && victim && victim.hp < victim.max_hp {
            victim.heal(blueprint.traits.applies_healing)
            if particles, particles.addHealing(victim.network_id)
        }
        
        // applies-attack (for spells)
        if blueprint.traits.applies_attack && victim {
            victim.attack += blueprint.traits.applies_attack
            if particles, particles.addAttackBonus(victim.network_id)
        }
        
        // applies-on-fire (for spells)
        if blueprint.traits.applies_on_fire && victim && !victim.traits.fire_resistant {
            victim.traits.on_fire = true
        }
        
        // draw-immediately (for spells)
        if blueprint.traits.draw_immediately {
            if player, player.drawCardsFromDeck(blueprint.traits.draw_immediately, player.name == gamedata.player_name)
        }
        
        // insta-kill (for spells)
        if blueprint.traits.insta_kill && victim {
            victim.hp = 0
            if particles, particles.addSmite(victim.network_id)
        }
        
        // everybody-dance-now (for spells)
        if blueprint.traits.everybody_dance_now {
            if blueprint.traits.everybody_dance_now > this.global_dancing,
                this.global_dancing = blueprint.traits.everybody_dance_now
            this.applyDancing(blueprint.traits.everybody_dance_now)
        }
        
        // everybody-burn-now (for spells)
        if blueprint.traits.everybody_burn_now {
            this.applyBurning(blueprint.traits.everybody_burn_now)
        }
        
        // applies-rage (for spells)
        if blueprint.traits.applies_rage {
            victim.traits.rage = true
        }
        
        // Ignore gives-mana (for spells) for the playing player because we will
        // have it apply immediately as the player plays the card
        // For good measure, we'll track it on other players though
        if blueprint.traits.gives_mana {
            if player && !(player.name == gamedata.player_name) {
                player.mana += blueprint.traits.gives_mana
            }
        }
        
        return true
    }
    
    func applyPassiveEffects(out particles *<*CardParticle> List) {
        each player Player in this.players {
            each CardInstance in player.board {
                // (on-fire || burning) && !fire-resistant
                if (it.traits.on_fire || it.traits.burning) && !it.traits.fire_resistant {
                    unless player.stat_card.has && player.stat_card.getPointer().traits.ignore_effect_damage {
                        it.hp -= (it.max_hp as float / 5.0f < 1.0f ? 1 : floorf(it.max_hp as float / 5.0f) as int)
                    }
                }
                
                // gains-hp <amount>
                if it.traits.gains_hp != 0 && it.hp > 0 {
                    it.hp += it.traits.gains_hp
                    if particles, particles.addHealing(it.network_id)
                }
                
                // gains-attack <amount>
                if it.traits.gains_attack != 0 {
                    it.attack += it.traits.gains_attack
                    if particles, particles.addAttackBonus(it.network_id)
                }
            }
            
            // applies-healing (for stat cards)
            if player.stat_card.has && player.stat_card.getPointer().traits.applies_healing != 0 {
                each CardInstance in player.board {
                    if particles && !it.isDead() && it.heal(player.stat_card.getPointer().traits.applies_healing),
                        particles.addHealing(it.network_id)
                }
            }
        }
    }
    
    func getCardStatuses <CardStatus> List {
        list <CardStatus> List
        each player Player in this.players, player.addCardStatusesToList(&list)
        return list.commit()
    }
    
    func removeDeadCards(lose_a_heart_if_none_left bool) {
        this_player *Player = this.getThisPlayer()
        
        each player Player in this.players {
            player.removeDeadCards(&player == this_player)
            
            // Lose a heart if no creatures left on board
            if lose_a_heart_if_none_left && player.board.length == 0 {
                player.hearts--
                unless gamedata.gamemode.exclusive_heart_mana_bonus, this.global_mana++
            }
        }
    }
    
    func findOwner(network_id CardNetworkID) *Player {
        each player Player in this.players {
            each card CardInstance in player.board {
                if card.network_id == network_id, return &player
            }
        }
        return null
    }
    
    func reduceTimedEffects {
        if this.global_dancing > 0, this.global_dancing--
        
        each player Player in static this.players {
            each card CardInstance in static player.board {
                if card.traits.dancing > 0, card.traits.dancing--
                if card.traits.burning > 0, card.traits.burning--
            }
        }
    }
    
    func applyDancing(amount int) {
        if amount <= 0, return
        
        each player Player in static this.players {
            each card CardInstance in static player.board {
                if card.traits.dancing < amount, card.traits.dancing = amount
            }
        }
    }
    
    func applyBurning(amount int) {
        if amount <= 0, return
        
        each player Player in static this.players {
            each card CardInstance in static player.board {
                if !card.traits.on_fire && !card.traits.fire_resistant && card.traits.burning < amount, card.traits.burning = amount
            }
        }
    }
}
